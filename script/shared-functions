#!/usr/bin/env sh
#
# To use, add to script
#
# DIR=$( dirname "$(readlink -f "$0")" )
# . $DIR/shared-functions

# On hosts that use RH Software collections, ensure that
# the profile is up and ready to go to source ruby.
if [ -f /opt/rh/ruby193/enable ]; then
  . /opt/rh/ruby193/enable
fi

PROJECT_ROOT=/opt/puppet
LOG_FILE=/var/log/puppet.log
NODE=$(hostname -s);
PATH=${PROJECT_ROOT}/bin:/usr/local/bin:$PATH

# From http://www.novell.com/coolsolutions/feature/11251.html
OS=`uname -s`
REV=`uname -r`
MACH=`uname -m`

if [ "$OS" = "OpenBSD" ]; then
    ARCH=`arch -s`
    BUNDLE_PATH='bundle20'
elif [ "$OS" = "Linux" ]; then
	KERNEL=`uname -r`
  BUNDLE_PATH='bundle'
	if [ -f /etc/redhat-release ]; then
		DIST='RedHat'
		REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`
    MAJORVER=`echo $REV | cut -d '.' -f1`
	elif [ -f /etc/SUSE-release ]; then
		DIST=`cat /etc/SUSE-release | tr "\n" ' '| sed s/VERSION.*//`
		REV=`cat /etc/SUSE-release | tr "\n" ' ' | sed s/.*=\ //`
	elif [ -f /etc/debian_version ] ; then
		DIST="Debian"
		REV="`cat /etc/debian_version`"
    CODENAME=`/usr/bin/lsb_release -c -s`
	fi
fi

git_ref_type() {
    REF=$1; shift;
    DIR=$1;

    [ -n "$DIR" ] || die "Missing ref name"
    [ -n "$REF" ] || die "Missing ref name"

    if git show-ref -q --verify "refs/heads/$REF" 2>/dev/null; then
        echo "branch"
    elif git show-ref -q --verify "refs/tags/$REF" 2>/dev/null; then
        echo "tag"
    elif git show-ref -q --verify "refs/remote/$REF" 2>/dev/null; then
        echo "remote"
    elif git rev-parse --verify "$REF^{commit}" >/dev/null 2>&1; then
        echo "hash"
    else
        echo "unknown"
    fi
    return 0
}

ensure_directory_exists() {
    DIR=$1

    if [ ! -d $DIR ]; then
        echo "Creating directory $DIR..."
        mkdir -p $DIR
    fi
}

ensure_directory_absent() {
    DIR=$1

    if [ "$DIR" = "/" ]; then
        log "Not going to continue... will not delete everything"
        exit 1
    fi

    if [ -d $DIR ]; then
        debug "Deleting directory $DIR..."
        rm -rf $DIR
    fi
}

safe_copy() {
    SOURCE_DIR=$1; shift;
    DEST_DIR=$1; shift;
    BACKUP_DIR=$1; shift;
    DEBUG=$1

    if [ -d $DEST_DIR ]; then
        cp -R $DEST_DIR $BACKUP_DIR
        if [ $? -eq 0 ]; then
            log "Success copy from $to $BACKUP_DIR"
        else
            log "Unable to backup $DEST_DIR to $BACKUP_DIR. Aborting"
            exit 1
        fi
    fi

    debug "Copying $SOURCE_DIR to $DEST_DIR"
    ensure_directory_absent $DEST_DIR
    cp -R $SOURCE_DIR $DEST_DIR

    if [ $? -eq 0 ]; then
        debug "Successful copy from $SOURCE_DIR to $DEST_DIR"
        debug "Cleaning up"

        if [ -d $BACKUP_DIR ]; then
            debug "Cleaning up backup directory $BACKUP_DIR"
            ensure_directory_absent $BACKUP_DIR
        fi
    else
        debug "Something went wrong... reverting!"
        ensure_directory_absent $DEST_DIR
        mv $BACKUP_DIR $DEST_DIR
    fi
}

git_setup_clean_branch() {
    GIT_REPO=$1; shift;
    DEST_DIR=$1; shift;
    REF=$1;

    debug "Cloning $GIT_REPO ($REF) to $DEST_DIR"
    git clone $GIT_REPO $DEST_DIR -b $REF
}

git_clean_and_update_branch() {
    DIR=$1; shift;
    BRANCH=$1;

    cd $DIR
    git_clean_and_update $DIR

    debug "Resetting $DIR to branch $BRANCH"
    git reset --hard $BRANCH
}

git_clean_and_update() {
    DIR=$1;

    cd $DIR
    debug "Updating git root..."
    git fetch --all
    git gc --auto
}

has_root_permissions() {
    if [ $(id -u) -ne 0 ]; then
        echo "false"
    else
        echo "true"
    fi
}

bash_tuple() {
  TEST=$1; shift;
  TRUE=$1; shift;
  FALSE=$1; shift

  if [ "$TEST" = "true" ]; then
    echo $TRUE
  else
    echo $FALSE
  fi
}

## Logging
info() {
  MESSAGE=$1
  if [ -z "$ST2_SILENCE" ]; then
    echo "[info] $MESSAGE"
  fi
}

log() {
  MESSAGE=$1
  echo "[log] $MESSAGE"
}

debug() {
  MESSAGE=$1
  if [ -n "$DEBUG" ]; then
    echo "[debug] $MESSAGE"
  fi
}
 
