#!/usr/bin/env bash
set -e
set -u
set -o pipefail

# Creates and returns a random temporary directory
#
# @ random-tmpdir
random-tmpdir() {
    echo $(mktemp -d)
}

# Recursively ensure a directory exists.
#
# @ recursive-mkdir <dir>
recursive-mkdir() {
    local _dir=
    _dir="${1:?}"

    debug "`recursive-mkdir`: creating dir $_dir"
    mkdir -p $_dir
}

# Recursively deletes a file or directory.
# DANGEROUS! No safeguards.
#
# @ recursive-rm <dir>
recursive-rm() {
    local _file=
    _file="${1:?}"

    debug "`recursive-rm`: removing $_file"
    rm -rf "${1:?}"
}

# safe wrapper to remove a directory. contains a series
# of logic checks to ensure specific directories are
# not deleted.
#
# returns boolean
#
# @ ensure-directory-absent <dir>
ensure-directory-absent() {
    local _dir=
    _dir="${1:?}"

    if string-equals $_dir "/";
    then
        fail-loudly "Will not continue... deleting / is not allowed directly"
    fi

    if directory-exists $_dir;
    then recursive-rm $_dir;
    else true;
    fi
}

# safe wrapper to create a directory. skips unnecessary checks
# by doing some prodding around before it blindly creates a directory
#
# returns boolean
#
# @ ensure-directory-exists <dir>
ensure-directory-exists() {
    local _dir=
    _dir="${1:?}"

    if directory-does-not-exist $_dir;
    then recursive-mkdir;
    else true;
    fi
}

# logic check to determine if a directory is absent on the fs
# inverse of `directory-exists`
#
# returns boolean
#
# @ directory-does-not-exist <dir>
directory-does-not-exist() {
    local _dir=
    _dir="${1:?}"

    if directory-exists $_dir;
    then false;
    else true;
    fi
}

# logic check to determine if a directory exists on the fs
# returns boolean
#
# @ directory-exists <dir>
directory-exists() {
    if [[ -d "${1:?}" ]];
    then true;
    else false;
    fi
}

# recursively copy files or directories from one place to
# another.
#
# @ recursive-copy <src> <dst>
recursive-copy() {
    local _src=
    local _dst=
    _src="${1:?}"
    _dst="${1:?}"

    debug "`recursive-copy`: from $_src to $_dst"
    cp -R "${1:?}" "${2:?}"
}

# copy a file or directory from one place to another. automatically
# backs up any file if it exists with a epoch timestamp.
#
# @ safe-copy /tmp/installer /opt/stackstorm/installer
safe-copy() {
    local _source_dir=
    local _dest_dir=
    local _backup_dir=
    _source_dir="${1:?}"
    _dest_dir="${2:?}"
    _backup_dir="${_dest_dir}.$(current-epoch)"

    if directory-exists $_dest_dir;
    then
        recursive-copy $_dest_dir $_backup_dir
    fi

    ensure-directory-absent $_dest_dir
    recursive-copy $_source_dir $_dest_dir
}

# deletes a file by creating a backup of itself with an epoch
# timestamp. Ensures the original file/dir is removed
#
# @ safe-delete /tmp/installer
safe-delete() {
    local _dir=
    local _backup_dir=
    _source_dir="${1:?}"
    _backup_dir="${_dir}.$(current-epoch)"

    ensure-directory-absent $_backup_dir
    recursive-copy $_dir $_backup_dir
    recursive-rm $_dir
}

# touches a file on the file-system only if it doesn't exist
#
# @ ensure-file-exists <file>
ensure-file-exists() {
    local _file=
    _file="${1:?}"

    if file-does-not-exist $_file;
    then
        debug "file $_file does not exist. creating..."
        touch $_file
    fi
}

# removes a file on the file-system, otherwise skips the operation
#
# @ ensure-file-absent <dir>
ensure-file-absent() {
    local _file=
    _file="${1:?}"

    if file-exists $_file;
    then recursive-rm $_file;
    else true;
    fi
}

# tests to determine if a file exists on the file-system
# inverse of `file-exists`
#
# returns boolean
#
# @ file-does-not-exist <file>
file-does-not-exist() {
    local _file=
    _file="${1:?}"

    if file-exists $_file;
    then false;
    else true;
    fi
}

# tests to determine if a file exists on the file-system
#
# returns boolean
#
# @ file-exists <file>
file-exists() {
    local _file=
    _file="${1:?}"

    if [[ -f "$_file" ]];
    then true;
    else false;
    fi
}

# tests to determine if an executable is in the current running
# environment. like: `which`
#
# returns boolean
#
# @ executable-in-path 'st2'
executable-in-path() {
    if hash "${1:?}" 2>/dev/null;
    then true;
    else false;
    fi
}

# tests to determine if an executable is not in the current running
# environment. like: `which`. Inverse of `executable-in-path`
#
# returns boolean
#
# @ executable-not-in-path 'st2'
executable-not-in-path() {
    if executable-in-path "${1:?}";
    then false;
    else true;
    fi
}

# echo a string to a completely new file. Takes a backup of the destination
# if it happens to exist before taking action.
#
# @ echo-to-new-file <message> <filename>
echo-to-new-file() {
    local _message=
    local _file=
    _message="${1:?}"
    _file="${2:?}"

    safe-copy $_file "${_file}.$(current-epoch)"
    ensure-file-absent $_file
    echo-to-file $_message $_file
}

# echo a string to a file, appending to the file itself
#
# @ echo-to-file <message> <file>
echo-to-file() {
    echo "${1:?}" >> "${2:?}"
}
